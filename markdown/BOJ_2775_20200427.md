---
title: "[BOJ.2775 / Python] 부녀회장이 될테야"
toc : true
toc_sticky : true
toc_label: "BOJ. 부녀회장이 될테야"

categories:
  - fundamentals
  - algorithms

tags:
  - algorithms
  - BOJ
  - Python

related: true
---

# Tries

## 1차 시도

어설픈 재귀는 시간 초과를 낳고..  

fibonacci도 그렇고, 이렇게 재귀가 두 번 이상 들어가면서 중복 출력이 많아지는 경우는  
하향식 보다는 상향식으로 해결하는게 나을 듯  

```python
def room(n, k):
  if n == 0 : return k
  if k == 0 : return 0
  elif k == 1: return 1

  print (n, k)
  return room(n, k-1) + room (n-1, k)

for i in range(int(input())) :
  k, n = int(input()), int(input())
  # print (k)
  # print (n)

  print (room (k, n))

```

## 2차 시도

14칸 정도니까 그냥 배열 만들어서 풀이  

이 간단한거 하는데 시간이 왜케 걸렸지..ㅋㅋ  
요즘 머리가 잘 안돌아간다..ㅜ  

```python
res = [[0 for i in range(15)] for j in range(15)]
res[0] = [i for i in range(15)]
for i in range(1, 15) :
  for j in range(1, 15) :
    res[i][j] = res[i-1][j] + res[i][j-1]
    # print (i, j)

# display (res)
    
for i in range(int(input())) :
  k, n = int(input()), int(input())
  # print (k)
  # print (n)

  print (res [k][n])
```

# Short Codings

분류가 수학으로 되어 있기도 하고, 대부분 short coding 순위권은 fatorial로 해결

이게 왜 그렇게 되는건지는 계산을 좀 더 해봐야겠다  


```python
for q in range(int(input())):
	a = int(input())
	b = int(input())
	h = [i for i in range(1, b + 1)]
	for i in range(a):
		for j in range(1, b):
			h[j] += h[j-1]
	print(h[-1])
```

내 풀이는 이렇게 간단하게 될 수 있는 거였는데..

14 by 14 였기 때문에 금방 끝났지만, 1만 by 1만이었다면 절대 불가능했을 풀이를 해버렸다